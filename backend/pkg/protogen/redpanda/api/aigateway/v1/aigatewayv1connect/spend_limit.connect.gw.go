// Code generated by protoc-gen-connect-gateway. DO NOT EDIT.
//
// Source: redpanda/api/aigateway/v1/spend_limit.proto

package aigatewayv1connect

import (
	context "context"
	fmt "fmt"

	runtime "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	v1 "go.panda.dev/redpanda-aigw/protos/gen/redpanda/api/aigateway/v1"
	connect_gateway "go.vallahaye.net/connect-gateway"
)

// SpendLimitServiceGatewayServer implements the gRPC server API for the SpendLimitService service.
type SpendLimitServiceGatewayServer struct {
	v1.UnimplementedSpendLimitServiceServer
	createSpendLimit   connect_gateway.UnaryHandler[v1.CreateSpendLimitRequest, v1.CreateSpendLimitResponse]
	getSpendLimit      connect_gateway.UnaryHandler[v1.GetSpendLimitRequest, v1.GetSpendLimitResponse]
	listSpendLimits    connect_gateway.UnaryHandler[v1.ListSpendLimitsRequest, v1.ListSpendLimitsResponse]
	updateSpendLimit   connect_gateway.UnaryHandler[v1.UpdateSpendLimitRequest, v1.UpdateSpendLimitResponse]
	deleteSpendLimit   connect_gateway.UnaryHandler[v1.DeleteSpendLimitRequest, v1.DeleteSpendLimitResponse]
	getSpendLimitUsage connect_gateway.UnaryHandler[v1.GetSpendLimitUsageRequest, v1.GetSpendLimitUsageResponse]
}

// NewSpendLimitServiceGatewayServer constructs a Connect-Gateway gRPC server for the
// SpendLimitService service.
func NewSpendLimitServiceGatewayServer(svc SpendLimitServiceHandler, opts ...connect_gateway.HandlerOption) *SpendLimitServiceGatewayServer {
	return &SpendLimitServiceGatewayServer{
		createSpendLimit:   connect_gateway.NewUnaryHandler(SpendLimitServiceCreateSpendLimitProcedure, svc.CreateSpendLimit, opts...),
		getSpendLimit:      connect_gateway.NewUnaryHandler(SpendLimitServiceGetSpendLimitProcedure, svc.GetSpendLimit, opts...),
		listSpendLimits:    connect_gateway.NewUnaryHandler(SpendLimitServiceListSpendLimitsProcedure, svc.ListSpendLimits, opts...),
		updateSpendLimit:   connect_gateway.NewUnaryHandler(SpendLimitServiceUpdateSpendLimitProcedure, svc.UpdateSpendLimit, opts...),
		deleteSpendLimit:   connect_gateway.NewUnaryHandler(SpendLimitServiceDeleteSpendLimitProcedure, svc.DeleteSpendLimit, opts...),
		getSpendLimitUsage: connect_gateway.NewUnaryHandler(SpendLimitServiceGetSpendLimitUsageProcedure, svc.GetSpendLimitUsage, opts...),
	}
}

func (s *SpendLimitServiceGatewayServer) CreateSpendLimit(ctx context.Context, req *v1.CreateSpendLimitRequest) (*v1.CreateSpendLimitResponse, error) {
	return s.createSpendLimit(ctx, req)
}

func (s *SpendLimitServiceGatewayServer) GetSpendLimit(ctx context.Context, req *v1.GetSpendLimitRequest) (*v1.GetSpendLimitResponse, error) {
	return s.getSpendLimit(ctx, req)
}

func (s *SpendLimitServiceGatewayServer) ListSpendLimits(ctx context.Context, req *v1.ListSpendLimitsRequest) (*v1.ListSpendLimitsResponse, error) {
	return s.listSpendLimits(ctx, req)
}

func (s *SpendLimitServiceGatewayServer) UpdateSpendLimit(ctx context.Context, req *v1.UpdateSpendLimitRequest) (*v1.UpdateSpendLimitResponse, error) {
	return s.updateSpendLimit(ctx, req)
}

func (s *SpendLimitServiceGatewayServer) DeleteSpendLimit(ctx context.Context, req *v1.DeleteSpendLimitRequest) (*v1.DeleteSpendLimitResponse, error) {
	return s.deleteSpendLimit(ctx, req)
}

func (s *SpendLimitServiceGatewayServer) GetSpendLimitUsage(ctx context.Context, req *v1.GetSpendLimitUsageRequest) (*v1.GetSpendLimitUsageResponse, error) {
	return s.getSpendLimitUsage(ctx, req)
}

// RegisterSpendLimitServiceHandlerGatewayServer registers the Connect handlers for the
// SpendLimitService "svc" to "mux".
func RegisterSpendLimitServiceHandlerGatewayServer(mux *runtime.ServeMux, svc SpendLimitServiceHandler, opts ...connect_gateway.HandlerOption) {
	if err := v1.RegisterSpendLimitServiceHandlerServer(context.TODO(), mux, NewSpendLimitServiceGatewayServer(svc, opts...)); err != nil {
		panic(fmt.Errorf("connect-gateway: %w", err))
	}
}
