// @generated by protoc-gen-es v1.6.0 with parameter "target=ts,import_extension="
// @generated from file redpanda/api/console/v1alpha1/cluster_status.proto (package redpanda.api.console.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * StatusType describes the health state of a component.
 *
 * @generated from enum redpanda.api.console.v1alpha1.StatusType
 */
export enum StatusType {
  /**
   * STATUS_TYPE_UNSPECIFIED is the default value.
   *
   * @generated from enum value: STATUS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * STATUS_TYPE_HEALTHY indicates the component is healthy.
   *
   * @generated from enum value: STATUS_TYPE_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * STATUS_TYPE_DEGRADED indicates the component is partially impaired.
   *
   * @generated from enum value: STATUS_TYPE_DEGRADED = 2;
   */
  DEGRADED = 2,

  /**
   * STATUS_TYPE_UNHEALTHY indicates the component is unhealthy or unreachable.
   *
   * @generated from enum value: STATUS_TYPE_UNHEALTHY = 3;
   */
  UNHEALTHY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(StatusType)
proto3.util.setEnumType(StatusType, "redpanda.api.console.v1alpha1.StatusType", [
  { no: 0, name: "STATUS_TYPE_UNSPECIFIED" },
  { no: 1, name: "STATUS_TYPE_HEALTHY" },
  { no: 2, name: "STATUS_TYPE_DEGRADED" },
  { no: 3, name: "STATUS_TYPE_UNHEALTHY" },
]);

/**
 * KafkaDistribution describes the Kafka software flavor.
 *
 * @generated from enum redpanda.api.console.v1alpha1.KafkaDistribution
 */
export enum KafkaDistribution {
  /**
   * KAFKA_DISTRIBUTION_UNSPECIFIED is the default value.
   *
   * @generated from enum value: KAFKA_DISTRIBUTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * KAFKA_DISTRIBUTION_UNKNOWN represents a Kafka distribution that is neither Redpanda
   * nor Apache Kafka.
   *
   * @generated from enum value: KAFKA_DISTRIBUTION_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * KAFKA_DISTRIBUTION_APACHE_KAFKA indicates an Apache Kafka implementation.
   *
   * @generated from enum value: KAFKA_DISTRIBUTION_APACHE_KAFKA = 2;
   */
  APACHE_KAFKA = 2,

  /**
   * KAFKA_DISTRIBUTION_REDPANDA indicates a Redpanda implementation.
   *
   * @generated from enum value: KAFKA_DISTRIBUTION_REDPANDA = 3;
   */
  REDPANDA = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(KafkaDistribution)
proto3.util.setEnumType(KafkaDistribution, "redpanda.api.console.v1alpha1.KafkaDistribution", [
  { no: 0, name: "KAFKA_DISTRIBUTION_UNSPECIFIED" },
  { no: 1, name: "KAFKA_DISTRIBUTION_UNKNOWN" },
  { no: 2, name: "KAFKA_DISTRIBUTION_APACHE_KAFKA" },
  { no: 3, name: "KAFKA_DISTRIBUTION_REDPANDA" },
]);

/**
 * @generated from enum redpanda.api.console.v1alpha1.LicenseType
 */
export enum LicenseType {
  /**
   * @generated from enum value: LICENSE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LICENSE_TYPE_COMMUNITY = 1;
   */
  COMMUNITY = 1,

  /**
   * @generated from enum value: LICENSE_TYPE_ENTERPRISE = 2;
   */
  ENTERPRISE = 2,

  /**
   * @generated from enum value: LICENSE_TYPE_TRIAL = 3;
   */
  TRIAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LicenseType)
proto3.util.setEnumType(LicenseType, "redpanda.api.console.v1alpha1.LicenseType", [
  { no: 0, name: "LICENSE_TYPE_UNSPECIFIED" },
  { no: 1, name: "LICENSE_TYPE_COMMUNITY" },
  { no: 2, name: "LICENSE_TYPE_ENTERPRISE" },
  { no: 3, name: "LICENSE_TYPE_TRIAL" },
]);

/**
 * @generated from enum redpanda.api.console.v1alpha1.LicenseSource
 */
export enum LicenseSource {
  /**
   * @generated from enum value: LICENSE_SOURCE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LICENSE_SOURCE_CLUSTER = 1;
   */
  CLUSTER = 1,

  /**
   * @generated from enum value: LICENSE_SOURCE_CONSOLE = 2;
   */
  CONSOLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LicenseSource)
proto3.util.setEnumType(LicenseSource, "redpanda.api.console.v1alpha1.LicenseSource", [
  { no: 0, name: "LICENSE_SOURCE_UNSPECIFIED" },
  { no: 1, name: "LICENSE_SOURCE_CLUSTER" },
  { no: 2, name: "LICENSE_SOURCE_CONSOLE" },
]);

/**
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaInfoRequest
 */
export class GetKafkaInfoRequest extends Message<GetKafkaInfoRequest> {
  constructor(data?: PartialMessage<GetKafkaInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaInfoRequest {
    return new GetKafkaInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaInfoRequest {
    return new GetKafkaInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaInfoRequest {
    return new GetKafkaInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaInfoRequest | PlainMessage<GetKafkaInfoRequest> | undefined, b: GetKafkaInfoRequest | PlainMessage<GetKafkaInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetKafkaInfoRequest, a, b);
  }
}

/**
 * KafkaInfo contains general Kafka cluster information.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaInfoResponse
 */
export class GetKafkaInfoResponse extends Message<GetKafkaInfoResponse> {
  /**
   * The health status for Kafka.
   *
   * @generated from field: redpanda.api.console.v1alpha1.ComponentStatus status = 1;
   */
  status?: ComponentStatus;

  /**
   * Version is the Kafka API version.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Distribution indicates the software flavor (e.g. Apache Kafka, Redpanda).
   *
   * @generated from field: redpanda.api.console.v1alpha1.KafkaDistribution distribution = 3;
   */
  distribution = KafkaDistribution.UNSPECIFIED;

  /**
   * BrokersOnline is the number of brokers currently online.
   *
   * @generated from field: int32 brokers_online = 4;
   */
  brokersOnline = 0;

  /**
   * BrokersExpected is the number of brokers expected.
   *
   * @generated from field: int32 brokers_expected = 5;
   */
  brokersExpected = 0;

  /**
   * TopicsCount is the total number of topics.
   *
   * @generated from field: int32 topics_count = 6;
   */
  topicsCount = 0;

  /**
   * PartitionsCount is the total number of partitions.
   *
   * @generated from field: int32 partitions_count = 7;
   */
  partitionsCount = 0;

  /**
   * ReplicasCount is the total number of replicas.
   *
   * @generated from field: int32 replicas_count = 8;
   */
  replicasCount = 0;

  /**
   * ControllerID is the ID of the controller broker.
   *
   * @generated from field: int32 controller_id = 9;
   */
  controllerId = 0;

  /**
   * Brokers lists details of individual Kafka brokers.
   *
   * @generated from field: repeated redpanda.api.console.v1alpha1.KafkaBroker brokers = 10;
   */
  brokers: KafkaBroker[] = [];

  /**
   * ClusterID is the unique identifier for the Kafka cluster.
   *
   * @generated from field: string cluster_id = 11;
   */
  clusterId = "";

  constructor(data?: PartialMessage<GetKafkaInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: ComponentStatus },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "distribution", kind: "enum", T: proto3.getEnumType(KafkaDistribution) },
    { no: 4, name: "brokers_online", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "brokers_expected", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "topics_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "partitions_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "replicas_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "controller_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 10, name: "brokers", kind: "message", T: KafkaBroker, repeated: true },
    { no: 11, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaInfoResponse {
    return new GetKafkaInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaInfoResponse {
    return new GetKafkaInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaInfoResponse {
    return new GetKafkaInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaInfoResponse | PlainMessage<GetKafkaInfoResponse> | undefined, b: GetKafkaInfoResponse | PlainMessage<GetKafkaInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetKafkaInfoResponse, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaAuthorizerInfoRequest
 */
export class GetKafkaAuthorizerInfoRequest extends Message<GetKafkaAuthorizerInfoRequest> {
  constructor(data?: PartialMessage<GetKafkaAuthorizerInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaAuthorizerInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaAuthorizerInfoRequest {
    return new GetKafkaAuthorizerInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaAuthorizerInfoRequest {
    return new GetKafkaAuthorizerInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaAuthorizerInfoRequest {
    return new GetKafkaAuthorizerInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaAuthorizerInfoRequest | PlainMessage<GetKafkaAuthorizerInfoRequest> | undefined, b: GetKafkaAuthorizerInfoRequest | PlainMessage<GetKafkaAuthorizerInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetKafkaAuthorizerInfoRequest, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaAuthorizerInfoResponse
 */
export class GetKafkaAuthorizerInfoResponse extends Message<GetKafkaAuthorizerInfoResponse> {
  /**
   * ACLCount is the number of ACLs created.
   *
   * @generated from field: int32 acl_count = 1;
   */
  aclCount = 0;

  constructor(data?: PartialMessage<GetKafkaAuthorizerInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaAuthorizerInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "acl_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaAuthorizerInfoResponse {
    return new GetKafkaAuthorizerInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaAuthorizerInfoResponse {
    return new GetKafkaAuthorizerInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaAuthorizerInfoResponse {
    return new GetKafkaAuthorizerInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaAuthorizerInfoResponse | PlainMessage<GetKafkaAuthorizerInfoResponse> | undefined, b: GetKafkaAuthorizerInfoResponse | PlainMessage<GetKafkaAuthorizerInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetKafkaAuthorizerInfoResponse, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetRedpandaInfoRequest
 */
export class GetRedpandaInfoRequest extends Message<GetRedpandaInfoRequest> {
  constructor(data?: PartialMessage<GetRedpandaInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetRedpandaInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRedpandaInfoRequest {
    return new GetRedpandaInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRedpandaInfoRequest {
    return new GetRedpandaInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRedpandaInfoRequest {
    return new GetRedpandaInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRedpandaInfoRequest | PlainMessage<GetRedpandaInfoRequest> | undefined, b: GetRedpandaInfoRequest | PlainMessage<GetRedpandaInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetRedpandaInfoRequest, a, b);
  }
}

/**
 * RedpandaInfo contains information provided by the Redpanda admin API.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetRedpandaInfoResponse
 */
export class GetRedpandaInfoResponse extends Message<GetRedpandaInfoResponse> {
  /**
   * Version is the Redpanda cluster version.
   *
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * UserCount is the number of users.
   *
   * @generated from field: int32 user_count = 2;
   */
  userCount = 0;

  constructor(data?: PartialMessage<GetRedpandaInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetRedpandaInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRedpandaInfoResponse {
    return new GetRedpandaInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRedpandaInfoResponse {
    return new GetRedpandaInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRedpandaInfoResponse {
    return new GetRedpandaInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRedpandaInfoResponse | PlainMessage<GetRedpandaInfoResponse> | undefined, b: GetRedpandaInfoResponse | PlainMessage<GetRedpandaInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetRedpandaInfoResponse, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusRequest
 */
export class GetRedpandaPartitionBalancerStatusRequest extends Message<GetRedpandaPartitionBalancerStatusRequest> {
  constructor(data?: PartialMessage<GetRedpandaPartitionBalancerStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRedpandaPartitionBalancerStatusRequest {
    return new GetRedpandaPartitionBalancerStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusRequest {
    return new GetRedpandaPartitionBalancerStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusRequest {
    return new GetRedpandaPartitionBalancerStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRedpandaPartitionBalancerStatusRequest | PlainMessage<GetRedpandaPartitionBalancerStatusRequest> | undefined, b: GetRedpandaPartitionBalancerStatusRequest | PlainMessage<GetRedpandaPartitionBalancerStatusRequest> | undefined): boolean {
    return proto3.util.equals(GetRedpandaPartitionBalancerStatusRequest, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse
 */
export class GetRedpandaPartitionBalancerStatusResponse extends Message<GetRedpandaPartitionBalancerStatusResponse> {
  /**
   * Status describes the current partition balancer state.
   *
   * @generated from field: redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Status status = 1;
   */
  status = GetRedpandaPartitionBalancerStatusResponse_Status.UNSPECIFIED;

  /**
   * Violations are the partition balancer violations.
   *
   * @generated from field: redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Violations violations = 2;
   */
  violations?: GetRedpandaPartitionBalancerStatusResponse_Violations;

  /**
   * SecondsSinceLastTick is the last time the partition balancer ran.
   *
   * @generated from field: int32 seconds_since_last_tick = 3;
   */
  secondsSinceLastTick = 0;

  /**
   * CurrentReassignmentsCount is the current number of partition
   * reassignments in progress.
   *
   * @generated from field: int32 current_reassignments_count = 4;
   */
  currentReassignmentsCount = 0;

  /**
   * PartitionsPendingForceRecovery specifies the number of partitions that
   * are yet to be force recovered. This is optional because not all Redpanda
   * versions include this parameter.
   *
   * @generated from field: optional int32 partitions_pending_force_recovery_count = 5;
   */
  partitionsPendingForceRecoveryCount?: number;

  /**
   * PartitionsPendingRecoveryList is a sample list of partitions pending
   * force recovery (limit capped to 10).
   *
   * @generated from field: repeated string partitions_pending_recovery_list = 6;
   */
  partitionsPendingRecoveryList: string[] = [];

  constructor(data?: PartialMessage<GetRedpandaPartitionBalancerStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(GetRedpandaPartitionBalancerStatusResponse_Status) },
    { no: 2, name: "violations", kind: "message", T: GetRedpandaPartitionBalancerStatusResponse_Violations },
    { no: 3, name: "seconds_since_last_tick", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "current_reassignments_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "partitions_pending_force_recovery_count", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "partitions_pending_recovery_list", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRedpandaPartitionBalancerStatusResponse {
    return new GetRedpandaPartitionBalancerStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusResponse {
    return new GetRedpandaPartitionBalancerStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusResponse {
    return new GetRedpandaPartitionBalancerStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRedpandaPartitionBalancerStatusResponse | PlainMessage<GetRedpandaPartitionBalancerStatusResponse> | undefined, b: GetRedpandaPartitionBalancerStatusResponse | PlainMessage<GetRedpandaPartitionBalancerStatusResponse> | undefined): boolean {
    return proto3.util.equals(GetRedpandaPartitionBalancerStatusResponse, a, b);
  }
}

/**
 * @generated from enum redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Status
 */
export enum GetRedpandaPartitionBalancerStatusResponse_Status {
  /**
   * STATUS_UNSPECIFIED is the default type.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The balancer is disabled.
   *
   * @generated from enum value: STATUS_OFF = 1;
   */
  OFF = 1,

  /**
   * The balancer is active but there is nothing to do.
   *
   * @generated from enum value: STATUS_READY = 2;
   */
  READY = 2,

  /**
   * The balancer is starting but has not run yet.
   *
   * @generated from enum value: STATUS_STARTING = 3;
   */
  STARTING = 3,

  /**
   * The balancer is active and is in the process of
   * scheduling partition movements.
   *
   * @generated from enum value: STATUS_IN_PROGRESS = 4;
   */
  IN_PROGRESS = 4,

  /**
   * There are some violations, but for some reason, the
   * balancer cannot make progress in mitigating them.
   *
   * @generated from enum value: STATUS_STALLED = 5;
   */
  STALLED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(GetRedpandaPartitionBalancerStatusResponse_Status)
proto3.util.setEnumType(GetRedpandaPartitionBalancerStatusResponse_Status, "redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_OFF" },
  { no: 2, name: "STATUS_READY" },
  { no: 3, name: "STATUS_STARTING" },
  { no: 4, name: "STATUS_IN_PROGRESS" },
  { no: 5, name: "STATUS_STALLED" },
]);

/**
 * Violations describes violations for the partition auto balancer.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Violations
 */
export class GetRedpandaPartitionBalancerStatusResponse_Violations extends Message<GetRedpandaPartitionBalancerStatusResponse_Violations> {
  /**
   * UnavailableNodes are the nodes that have been unavailable after a time
   * set by 'partition_autobalancing_node_availability_timeout_sec' property.
   *
   * @generated from field: repeated int32 unavailable_nodes = 1;
   */
  unavailableNodes: number[] = [];

  /**
   * OverDiskLimitNodes are the nodes that surpassed the threshold of used
   * disk percentage set by 'partition_autobalancing_max_disk_usage_percent'
   * property.
   *
   * @generated from field: repeated int32 over_disk_limit_nodes = 2;
   */
  overDiskLimitNodes: number[] = [];

  constructor(data?: PartialMessage<GetRedpandaPartitionBalancerStatusResponse_Violations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetRedpandaPartitionBalancerStatusResponse.Violations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unavailable_nodes", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 2, name: "over_disk_limit_nodes", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRedpandaPartitionBalancerStatusResponse_Violations {
    return new GetRedpandaPartitionBalancerStatusResponse_Violations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusResponse_Violations {
    return new GetRedpandaPartitionBalancerStatusResponse_Violations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRedpandaPartitionBalancerStatusResponse_Violations {
    return new GetRedpandaPartitionBalancerStatusResponse_Violations().fromJsonString(jsonString, options);
  }

  static equals(a: GetRedpandaPartitionBalancerStatusResponse_Violations | PlainMessage<GetRedpandaPartitionBalancerStatusResponse_Violations> | undefined, b: GetRedpandaPartitionBalancerStatusResponse_Violations | PlainMessage<GetRedpandaPartitionBalancerStatusResponse_Violations> | undefined): boolean {
    return proto3.util.equals(GetRedpandaPartitionBalancerStatusResponse_Violations, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetConsoleInfoRequest
 */
export class GetConsoleInfoRequest extends Message<GetConsoleInfoRequest> {
  constructor(data?: PartialMessage<GetConsoleInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetConsoleInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConsoleInfoRequest {
    return new GetConsoleInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConsoleInfoRequest {
    return new GetConsoleInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConsoleInfoRequest {
    return new GetConsoleInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConsoleInfoRequest | PlainMessage<GetConsoleInfoRequest> | undefined, b: GetConsoleInfoRequest | PlainMessage<GetConsoleInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetConsoleInfoRequest, a, b);
  }
}

/**
 * ConsoleInfo contains version and build information about Redpanda Console.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetConsoleInfoResponse
 */
export class GetConsoleInfoResponse extends Message<GetConsoleInfoResponse> {
  /**
   * Console version.
   *
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * BuiltAt indicates the build time.
   *
   * @generated from field: string built_at = 2;
   */
  builtAt = "";

  constructor(data?: PartialMessage<GetConsoleInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetConsoleInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "built_at", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConsoleInfoResponse {
    return new GetConsoleInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConsoleInfoResponse {
    return new GetConsoleInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConsoleInfoResponse {
    return new GetConsoleInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConsoleInfoResponse | PlainMessage<GetConsoleInfoResponse> | undefined, b: GetConsoleInfoResponse | PlainMessage<GetConsoleInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetConsoleInfoResponse, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaConnectInfoRequest
 */
export class GetKafkaConnectInfoRequest extends Message<GetKafkaConnectInfoRequest> {
  constructor(data?: PartialMessage<GetKafkaConnectInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaConnectInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaConnectInfoRequest {
    return new GetKafkaConnectInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoRequest {
    return new GetKafkaConnectInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoRequest {
    return new GetKafkaConnectInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaConnectInfoRequest | PlainMessage<GetKafkaConnectInfoRequest> | undefined, b: GetKafkaConnectInfoRequest | PlainMessage<GetKafkaConnectInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetKafkaConnectInfoRequest, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaConnectInfoResponse
 */
export class GetKafkaConnectInfoResponse extends Message<GetKafkaConnectInfoResponse> {
  /**
   * Clusters contains details for each Kafka Connect cluster.
   *
   * @generated from field: repeated redpanda.api.console.v1alpha1.GetKafkaConnectInfoResponse.KafkaConnectCluster clusters = 1;
   */
  clusters: GetKafkaConnectInfoResponse_KafkaConnectCluster[] = [];

  constructor(data?: PartialMessage<GetKafkaConnectInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaConnectInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusters", kind: "message", T: GetKafkaConnectInfoResponse_KafkaConnectCluster, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaConnectInfoResponse {
    return new GetKafkaConnectInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoResponse {
    return new GetKafkaConnectInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoResponse {
    return new GetKafkaConnectInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaConnectInfoResponse | PlainMessage<GetKafkaConnectInfoResponse> | undefined, b: GetKafkaConnectInfoResponse | PlainMessage<GetKafkaConnectInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetKafkaConnectInfoResponse, a, b);
  }
}

/**
 * KafkaConnectCluster represents a single Kafka Connect cluster.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetKafkaConnectInfoResponse.KafkaConnectCluster
 */
export class GetKafkaConnectInfoResponse_KafkaConnectCluster extends Message<GetKafkaConnectInfoResponse_KafkaConnectCluster> {
  /**
   * Name is the Kafka Connect cluster name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Status indicates the health of the cluster.
   *
   * @generated from field: redpanda.api.console.v1alpha1.ComponentStatus status = 2;
   */
  status?: ComponentStatus;

  /**
   * Host is the address of the Kafka Connect cluster.
   *
   * @generated from field: string host = 3;
   */
  host = "";

  /**
   * Version is the version of the Kafka Connect cluster.
   *
   * @generated from field: string version = 4;
   */
  version = "";

  /**
   * InstalledPlugins is the number of plugins installed.
   *
   * @generated from field: int32 installed_plugins_count = 5;
   */
  installedPluginsCount = 0;

  constructor(data?: PartialMessage<GetKafkaConnectInfoResponse_KafkaConnectCluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetKafkaConnectInfoResponse.KafkaConnectCluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "message", T: ComponentStatus },
    { no: 3, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "installed_plugins_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKafkaConnectInfoResponse_KafkaConnectCluster {
    return new GetKafkaConnectInfoResponse_KafkaConnectCluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoResponse_KafkaConnectCluster {
    return new GetKafkaConnectInfoResponse_KafkaConnectCluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKafkaConnectInfoResponse_KafkaConnectCluster {
    return new GetKafkaConnectInfoResponse_KafkaConnectCluster().fromJsonString(jsonString, options);
  }

  static equals(a: GetKafkaConnectInfoResponse_KafkaConnectCluster | PlainMessage<GetKafkaConnectInfoResponse_KafkaConnectCluster> | undefined, b: GetKafkaConnectInfoResponse_KafkaConnectCluster | PlainMessage<GetKafkaConnectInfoResponse_KafkaConnectCluster> | undefined): boolean {
    return proto3.util.equals(GetKafkaConnectInfoResponse_KafkaConnectCluster, a, b);
  }
}

/**
 * @generated from message redpanda.api.console.v1alpha1.GetSchemaRegistryInfoRequest
 */
export class GetSchemaRegistryInfoRequest extends Message<GetSchemaRegistryInfoRequest> {
  constructor(data?: PartialMessage<GetSchemaRegistryInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetSchemaRegistryInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSchemaRegistryInfoRequest {
    return new GetSchemaRegistryInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSchemaRegistryInfoRequest {
    return new GetSchemaRegistryInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSchemaRegistryInfoRequest {
    return new GetSchemaRegistryInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSchemaRegistryInfoRequest | PlainMessage<GetSchemaRegistryInfoRequest> | undefined, b: GetSchemaRegistryInfoRequest | PlainMessage<GetSchemaRegistryInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetSchemaRegistryInfoRequest, a, b);
  }
}

/**
 * SchemaRegistryInfo contains information about the configured Schema Registry.
 *
 * @generated from message redpanda.api.console.v1alpha1.GetSchemaRegistryInfoResponse
 */
export class GetSchemaRegistryInfoResponse extends Message<GetSchemaRegistryInfoResponse> {
  /**
   * Status indicates the health status of the Schema Registry.
   *
   * @generated from field: redpanda.api.console.v1alpha1.ComponentStatus status = 1;
   */
  status?: ComponentStatus;

  /**
   * RegisteredSubjectsCount is the number of subjects registered.
   *
   * @generated from field: int32 registered_subjects_count = 2;
   */
  registeredSubjectsCount = 0;

  constructor(data?: PartialMessage<GetSchemaRegistryInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.GetSchemaRegistryInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: ComponentStatus },
    { no: 2, name: "registered_subjects_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSchemaRegistryInfoResponse {
    return new GetSchemaRegistryInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSchemaRegistryInfoResponse {
    return new GetSchemaRegistryInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSchemaRegistryInfoResponse {
    return new GetSchemaRegistryInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSchemaRegistryInfoResponse | PlainMessage<GetSchemaRegistryInfoResponse> | undefined, b: GetSchemaRegistryInfoResponse | PlainMessage<GetSchemaRegistryInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetSchemaRegistryInfoResponse, a, b);
  }
}

/**
 * ComponentStatus provides health status information common to all components.
 *
 * @generated from message redpanda.api.console.v1alpha1.ComponentStatus
 */
export class ComponentStatus extends Message<ComponentStatus> {
  /**
   * Status is the overall health.
   *
   * @generated from field: redpanda.api.console.v1alpha1.StatusType status = 1;
   */
  status = StatusType.UNSPECIFIED;

  /**
   * StatusReason provides details if the component is not healthy.
   *
   * @generated from field: string status_reason = 2;
   */
  statusReason = "";

  constructor(data?: PartialMessage<ComponentStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.ComponentStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(StatusType) },
    { no: 2, name: "status_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentStatus {
    return new ComponentStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentStatus {
    return new ComponentStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentStatus {
    return new ComponentStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentStatus | PlainMessage<ComponentStatus> | undefined, b: ComponentStatus | PlainMessage<ComponentStatus> | undefined): boolean {
    return proto3.util.equals(ComponentStatus, a, b);
  }
}

/**
 * KafkaBroker represents details about a single Kafka broker.
 *
 * @generated from message redpanda.api.console.v1alpha1.KafkaBroker
 */
export class KafkaBroker extends Message<KafkaBroker> {
  /**
   * BrokerID is the unique identifier of the broker.
   *
   * @generated from field: int32 broker_id = 1;
   */
  brokerId = 0;

  /**
   * Host is the address or hostname of the broker.
   *
   * @generated from field: string host = 2;
   */
  host = "";

  /**
   * RackID (availability zone) configured for this broker.
   *
   * @generated from field: optional string rack_id = 3;
   */
  rackId?: string;

  constructor(data?: PartialMessage<KafkaBroker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "redpanda.api.console.v1alpha1.KafkaBroker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "broker_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rack_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KafkaBroker {
    return new KafkaBroker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KafkaBroker {
    return new KafkaBroker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KafkaBroker {
    return new KafkaBroker().fromJsonString(jsonString, options);
  }

  static equals(a: KafkaBroker | PlainMessage<KafkaBroker> | undefined, b: KafkaBroker | PlainMessage<KafkaBroker> | undefined): boolean {
    return proto3.util.equals(KafkaBroker, a, b);
  }
}

